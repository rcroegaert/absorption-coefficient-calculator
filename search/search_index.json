{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Absorption Coefficient Calculator!","text":"<p>This software is a tool for calculating the absorption coefficient of different types of absorbers.  The goal of this tool is to enable anyone to quickly calculate the absorption coefficient for different frequencies,  either for one material or multilayered materials. It was developed within the \"Python &amp; Akustik\" course at the TU Berlin, imparted by Prof. Dr. Ennes Sarradj in the summer semester of 2023.</p> <p>Try it here!</p> <p>The app is divided in three parts. The first part is the Global Parameters. Here you can choose the frequency range, angle of incidence, plot type and the air conditions.</p> <p>The second part is the Material Parameters. Here you can define the material depending on the model you want to calculate the absorption coefficient for.  You can add a maximum of 5 materials. The models are further explained in the models section.</p> <p>The third part shows the Results. Here you can see the output of the calculations in a graph and as a table.  Additionally, you can download the results as a .csv file.</p>"},{"location":"absorptioncoeff/","title":"TMM","text":""},{"location":"absorptioncoeff/#about","title":"About","text":"<p>This class calculates the absorption coefficient of different materials together. It uses the Transfer Matrix Method, which treats a multilayered system as a series of matrices representing the different layers and interfaces.  Each matrix describes how the wave propagates and interacts with the material at that particular interface.  By multiplying these matrices together, the overall transfer matrix of the entire system can be obtained.</p> <p>You can read more about TMM here. </p>"},{"location":"absorptioncoeff/#src.absorptioncoeff.AbsorptionCoeff","title":"<code>AbsorptionCoeff</code>","text":"<p>Absorption coefficient calculator for a given frequency range and a given angle of incidence.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>list</code> <p>List of Transfer Matrices.</p> required <code>Z0</code> <code>float</code> <p>Impedance of the air.</p> required <code>theta</code> <code>float</code> <p>Angle of incidence in degrees.</p> required Source code in <code>src/absorptioncoeff.py</code> <pre><code>class AbsorptionCoeff:\n\"\"\"Absorption coefficient calculator for a given frequency range and a given angle of incidence.\n\n    Args:\n        T (list): List of Transfer Matrices.\n        Z0 (float): Impedance of the air.\n        theta (float): Angle of incidence in degrees.\n    \"\"\"\n\n    def __init__(self, T, Z0, theta):\n        self.T = T\n        self.Z0 = Z0\n        self.theta = theta\n\n    def abs_coeff(self):\n\"\"\"Function that calculates the absorption coefficient\n\n        Args:\n            self : Object of the class AbsorptionCoeff\n\n        Returns:\n            alpha (float): Absorption coefficient\n        \"\"\"\n        T_total = self.T[0]\n        for i in range(1, len(self.T)):\n            T_total = np.matmul(T_total, self.T[i])\n\n        R = (T_total[0, 0] * np.cos(self.theta) - self.Z0 * T_total[1, 0]) / (\n                    T_total[0, 0] * np.cos(self.theta) + self.Z0 * T_total[1, 0])\n        alpha = 1 - (np.abs(R) ** 2)\n        return alpha\n</code></pre>"},{"location":"absorptioncoeff/#src.absorptioncoeff.AbsorptionCoeff.abs_coeff","title":"<code>abs_coeff()</code>","text":"<p>Function that calculates the absorption coefficient</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>Object of the class AbsorptionCoeff</p> required <p>Returns:</p> Name Type Description <code>alpha</code> <code>float</code> <p>Absorption coefficient</p> Source code in <code>src/absorptioncoeff.py</code> <pre><code>def abs_coeff(self):\n\"\"\"Function that calculates the absorption coefficient\n\n    Args:\n        self : Object of the class AbsorptionCoeff\n\n    Returns:\n        alpha (float): Absorption coefficient\n    \"\"\"\n    T_total = self.T[0]\n    for i in range(1, len(self.T)):\n        T_total = np.matmul(T_total, self.T[i])\n\n    R = (T_total[0, 0] * np.cos(self.theta) - self.Z0 * T_total[1, 0]) / (\n                T_total[0, 0] * np.cos(self.theta) + self.Z0 * T_total[1, 0])\n    alpha = 1 - (np.abs(R) ** 2)\n    return alpha\n</code></pre>"},{"location":"models/","title":"Models","text":""},{"location":"models/#about","title":"About","text":"<p>The classes for each absorber model used in the calculator are defined here. There is a base class \"AbsorberModel\" which defines the basic structure of each model. Each model inherits from this base class and defines its own extra parameters.</p> <p>There are 4 models of absorbers currently implemented, all can be found in 1:</p> <ul> <li>Porous Absorber: Johnson-Champoux-Allard Model.</li> <li>Porous Absorber: Delany-Bazley Model.</li> <li>Microperforated Panel: Maa\u00b4s Model.</li> <li>Air</li> <li>Plate: Infinite Elastic Wall Model.</li> </ul> <p>Info</p> <p>The Delany &amp; Bazley code is implemented but is not being used by the calculator.</p> <p>Error</p> <p>The values calculated for the Plate Model are not consistent with the goal of this tool. When using the plate model, the transmission loss is of importance, not the absorption.</p> <ol> <li> <p>No\u00e9 Jim\u00e9nez. Acoustic waves in periodic structures, metamaterials, and porous media: From fundamentals to industrial applications. Springer, 2022.\u00a0\u21a9</p> </li> </ol>"},{"location":"models/#src.models.AbsorberModelInterface","title":"<code>AbsorberModelInterface</code>","text":"<p>Base class interface for all Absorber Models.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>omega</code> <code>float</code> <p>Angular frequency</p> required Source code in <code>src/models.py</code> <pre><code>class AbsorberModelInterface:\n\"\"\"Base class interface for all Absorber Models.\n\n    Args:\n        f (float): Frequency\n        air_density (float): Density of air\n        air speed (float): Speed of air\n        L (float): Thickness of the layer\n        viscosity (float): Viscosity of air\n        omega (float): Angular frequency\n    \"\"\"\n\n    f = air_density = omega = 0.0\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity):\n        self.f = f\n        self.air_density = air_density\n        self.air_speed = air_speed\n        self.L1 = L1\n        self.omega = 2 * np.pi * self.f\n        self.viscosity = viscosity\n\n    def get_k(self):\n\"\"\"Calculates the wave number. Different for each model, see source code for details.\n\n        Returns:\n            k (float): Wave number\n        \"\"\"\n        pass\n\n    def get_Z(self):\n\"\"\"Calculates the surface impedance. Different for each model, see source code for details.\n\n        Returns:\n            Z (float): Surface impedance\n        \"\"\"\n        pass\n\n    def get_T(self):\n\"\"\"Calculates the transfer matrix. Different for each model, see source code for details.\n\n        Returns:\n            T (float): Transfer Matrix of the absorber\n        \"\"\"\n        pass\n</code></pre>"},{"location":"models/#src.models.AbsorberModelInterface.get_T","title":"<code>get_T()</code>","text":"<p>Calculates the transfer matrix. Different for each model, see source code for details.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber</p> Source code in <code>src/models.py</code> <pre><code>def get_T(self):\n\"\"\"Calculates the transfer matrix. Different for each model, see source code for details.\n\n    Returns:\n        T (float): Transfer Matrix of the absorber\n    \"\"\"\n    pass\n</code></pre>"},{"location":"models/#src.models.AbsorberModelInterface.get_Z","title":"<code>get_Z()</code>","text":"<p>Calculates the surface impedance. Different for each model, see source code for details.</p> <p>Returns:</p> Name Type Description <code>Z</code> <code>float</code> <p>Surface impedance</p> Source code in <code>src/models.py</code> <pre><code>def get_Z(self):\n\"\"\"Calculates the surface impedance. Different for each model, see source code for details.\n\n    Returns:\n        Z (float): Surface impedance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"models/#src.models.AbsorberModelInterface.get_k","title":"<code>get_k()</code>","text":"<p>Calculates the wave number. Different for each model, see source code for details.</p> <p>Returns:</p> Name Type Description <code>k</code> <code>float</code> <p>Wave number</p> Source code in <code>src/models.py</code> <pre><code>def get_k(self):\n\"\"\"Calculates the wave number. Different for each model, see source code for details.\n\n    Returns:\n        k (float): Wave number\n    \"\"\"\n    pass\n</code></pre>"},{"location":"models/#src.models.Air_Absorber","title":"<code>Air_Absorber</code>","text":"<p>             Bases: <code>AbsorberModelInterface</code></p> <p>Air Model</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>kx</code> <code>float</code> <p>Wave number in x direction</p> required <p>Returns:</p> Name Type Description <code>Z</code> <code>float</code> <p>Surface impedance</p> <code>k</code> <code>float</code> <p>Wave number</p> <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber</p> Source code in <code>src/models.py</code> <pre><code>class Air_Absorber(AbsorberModelInterface):\n\"\"\"Air Model\n\n    Args:\n        f (float): Frequency\n        air_density (float): Density of air\n        air speed (float): Speed of air\n        L (float): Thickness of the layer\n        viscosity (float): Viscosity of air\n\n        kx (float): Wave number in x direction\n\n    Returns:\n        Z (float): Surface impedance\n        k (float): Wave number\n        T (float): Transfer Matrix of the absorber\n    \"\"\"\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity, kx):\n        super().__init__(f, air_density, air_speed, L1, viscosity)\n\n        self.kx = kx\n\n    def get_k(self):\n        k = 2 * np.pi * self.f / self.air_speed\n        return k\n\n    def get_Z(self):\n        Z = self.air_density * self.air_speed\n        return Z\n\n    def get_T(self):\n        k = self.get_k()\n        Z = self.get_Z()\n        k_z = np.sqrt(k ** 2 - self.kx ** 2)\n        T = np.array([[np.cos(k_z * self.L1), 1j * Z * (k / k_z) * np.sin(k_z * self.L1)],\n                      [(1j / Z) * (k_z / k) * np.sin(k_z * self.L1), np.cos(k_z * self.L1)]])\n        return T\n</code></pre>"},{"location":"models/#src.models.PerforatedPlate_Absorber","title":"<code>PerforatedPlate_Absorber</code>","text":"<p>             Bases: <code>AbsorberModelInterface</code></p> <p>Maa\u00b4s Model for a rigid micro-perforated plate absorber material.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>d_hole</code> <code>float</code> <p>Diameter of hole</p> required <code>a</code> <code>float</code> <p>Distance between holes</p> required <code>phi</code> <code>float</code> <p>Porosity</p> required <code>s</code> <code>float</code> <p>Ratio of the holes' diameter to the boundary layer thickness</p> required <code>S</code> <code>float</code> <p>Area of the edge effects</p> required <code>e</code> <code>float</code> <p>DONT KNOW THE NAME</p> required <code>F_e</code> <code>float</code> <p>Fok function</p> required <p>Returns:</p> Name Type Description <code>Z</code> <code>float</code> <p>Surface impedance</p> <code>k</code> <code>float</code> <p>Wave number</p> <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber</p> Source code in <code>src/models.py</code> <pre><code>class PerforatedPlate_Absorber(AbsorberModelInterface):\n\"\"\"Maa\u00b4s Model for a rigid micro-perforated plate absorber material.\n\n    Args:\n        f (float): Frequency\n        air_density (float): Density of air\n        air speed (float): Speed of air\n        L (float): Thickness of the layer\n        viscosity (float): Viscosity of air\n\n        d_hole (float): Diameter of hole\n        a (float): Distance between holes\n\n        phi (float): Porosity\n        s (float): Ratio of the holes' diameter to the boundary layer thickness\n        S (float): Area of the edge effects\n        e (float): DONT KNOW THE NAME\n        F_e (float): Fok function\n\n    Returns:\n        Z (float): Surface impedance\n        k (float): Wave number\n        T (float): Transfer Matrix of the absorber\n    \"\"\"\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity, d_hole, a):\n        super().__init__(f, air_density, air_speed, L1, viscosity)\n\n        self.d_hole = d_hole/1000\n        self.a = a/1000\n\n    def get_k(self):\n        k = self.omega / self.air_speed\n        return k\n\n    def get_Z(self):\n        self.phi = (np.pi / 4) * (self.d_hole / self.a) ** 2\n        self.e = 1.1284 * np.sqrt(self.phi)\n        self.s = self.d_hole * np.sqrt(self.air_density * self.omega / 4 / self.viscosity)\n        self.F_e = (1 - 1.4092 * self.e + 0.33818 * (self.e ** 3) + 0.06793 *\n                    (self.e ** 5) - 0.02287 * (self.e ** 6) + 0.03015 *\n                    (self.e ** 7) - 0.01641 * (self.e ** 8)) ** (-1)\n        J_0 = jv(0, self.s * np.sqrt(-1j))\n        J_1 = jv(1, self.s * np.sqrt(-1j))\n        Z = ((np.sqrt(2 * self.air_density * self.omega * self.viscosity) / 2 * self.phi) +\n             (1j * (self.omega * self.air_density / self.phi)) * (0.85 * self.d_hole / self.F_e +\n                                                self.L1 * (1 - 2 * J_1 / (self.s * np.sqrt(-1j)) / J_0) ** (-1)))\n        return Z\n\n    def get_T(self):\n        T = np.array([[1, self.get_Z()],\n                      [0, 1]])\n        return T\n</code></pre>"},{"location":"models/#src.models.Plate_Absorber","title":"<code>Plate_Absorber</code>","text":"<p>             Bases: <code>AbsorberModelInterface</code></p> <p>Infinite Elastic Vibrating Wall Model for a plate absorber material.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>theta</code> <code>float</code> <p>Angle of incidence</p> required <code>density</code> <code>float</code> <p>Density of the plate</p> required <code>E</code> <code>float</code> <p>Young's modulus</p> required <code>nu</code> <code>float</code> <p>Poisson's ratio</p> required <code>eta</code> <code>float</code> <p>Loss factor</p> required <p>Returns:</p> Name Type Description <code>fc</code> <code>float</code> <p>Critical frequency</p> <code>Z</code> <code>float</code> <p>Surface impedance</p> <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber</p> Source code in <code>src/models.py</code> <pre><code>class Plate_Absorber(AbsorberModelInterface):\n\"\"\"Infinite Elastic Vibrating Wall Model for a plate absorber material.\n\n        Args:\n            f (float): Frequency\n            air_density (float): Density of air\n            air speed (float): Speed of air\n            L (float): Thickness of the layer\n            viscosity (float): Viscosity of air\n\n            theta (float): Angle of incidence\n            density (float): Density of the plate\n            E (float): Young's modulus\n            nu (float): Poisson's ratio\n            eta (float): Loss factor\n\n\n        Returns:\n            fc (float): Critical frequency\n            Z (float): Surface impedance\n            T (float): Transfer Matrix of the absorber\n        \"\"\"\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity, theta, density, E, nu, eta):\n        super().__init__(f, air_density, air_speed, L1, viscosity)\n\n        self.omega = 2 * np.pi * self.f\n        self.theta = theta\n        self.density = density\n        self.E = E\n        self.nu = nu\n        self.eta = eta\n\n        self.m_dot = self.density * self.L1\n        self.D = self.E * self.L1 ** 3 / (12 * (1 - self.nu ** 2))\n\n    def get_fc(self):\n        fc = (self.air_speed ** 2) / (2 * np.pi) * np.sqrt(self.m_dot / self.D)\n        return fc\n\n    def get_Z(self):\n        fc = self.get_fc()\n        Z = 1j * self.m_dot * self.omega * (1 - ((self.f/fc)**2) * (1 + 1j*self.eta) * np.sin(self.theta)**4)\n        return Z\n\n    def get_T(self):\n        Z = self.get_Z()\n        T = np.array([[1, Z],\n                      [0, 1]])\n        return T\n</code></pre>"},{"location":"models/#src.models.Porous_Absorber_DB","title":"<code>Porous_Absorber_DB</code>","text":"<p>             Bases: <code>AbsorberModelInterface</code></p> <p>Delany &amp; Bazley Empirical Model for a porous absorber material.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>sigma</code> <code>float</code> <p>Flow resistivity of material</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>kx</code> <code>float</code> <p>Wave number in x direction</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>float</code> <p>Wave number when calling get_k()</p> <code>Z</code> <code>float</code> <p>Surface impedance when calling get_Z()</p> <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber when calling get_T()</p> Source code in <code>src/models.py</code> <pre><code>class Porous_Absorber_DB(AbsorberModelInterface):\n\"\"\"Delany &amp; Bazley Empirical Model for a porous absorber material.\n\n    Args:\n        f (float): Frequency\n        air_density (float): Density of air\n        air speed (float): Speed of air\n        sigma (float): Flow resistivity of material\n        L (float): Thickness of the layer\n        viscosity (float): Viscosity of air\n        kx (float): Wave number in x direction\n\n\n    Returns:\n        k (float): Wave number when calling get_k()\n        Z (float): Surface impedance when calling get_Z()\n        T (float): Transfer Matrix of the absorber when calling get_T()\n    \"\"\"\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity, sigma, kx):\n        super().__init__(f, air_density, air_speed, L1, viscosity)\n\n        self.sigma = sigma\n        self.kx = kx\n        self.X = (self.air_density * self.f) / self.sigma\n\n    def get_k(self):\n        k = self.omega / self.air_speed * (1 + 0.0978 * self.X ** (-0.7) - 1j * 0.189 * self.X ** (-0.595))\n        return k\n\n    def get_Z(self):\n        Z = self.air_density * self.air_speed * (1 + 0.0571 * self.X ** (-0.754) - 1j * 0.087 * self.X ** (-0.732))\n        return Z\n\n    def get_T(self):\n        k = self.get_k()\n        Z = self.get_Z()\n        k_z = np.sqrt(k ** 2 - self.kx ** 2)\n\n        T = np.array([[np.cos(k_z * self.L1), 1j * Z * (k / k_z) * np.sin(k_z * self.L1)],\n                      [(1j / Z) * (k_z / k) * np.sin(k_z * self.L1), np.cos(k_z * self.L1)]])\n        return T\n</code></pre>"},{"location":"models/#src.models.Porous_Absorber_JAC","title":"<code>Porous_Absorber_JAC</code>","text":"<p>             Bases: <code>AbsorberModelInterface</code></p> <p>Johnson-Champoux-Allard Model for a porous absorber material.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Frequency</p> required <code>air_density</code> <code>float</code> <p>Density of air</p> required <code>air</code> <code>speed (float</code> <p>Speed of air</p> required <code>sigma</code> <code>float</code> <p>Flow resistivity of material</p> required <code>L</code> <code>float</code> <p>Thickness of the layer</p> required <code>viscosity</code> <code>float</code> <p>Viscosity of air</p> required <code>air_pressure</code> <code>float</code> <p>Air pressure</p> required <code>phi</code> <code>float</code> <p>Porosity</p> required <code>alpha_inf</code> <code>float</code> <p>Tortuosity</p> required <code>kx</code> <code>float</code> <p>Wave number in x direction</p> required <code>gamma</code> <code>float</code> <p>Specific heat ratio</p> required <code>kappa</code> <code>float</code> <p>Thermal conductivity</p> required <code>cp</code> <code>float</code> <p>Specific heat capacity</p> required <code>K0</code> <code>float</code> <p>Bulk modulus</p> required <code>delta_v</code> <code>float</code> <p>Viscous boundary layer thickness</p> required <code>delta_h</code> <code>float</code> <p>Thermal boundary layer thickness</p> required <code>Pr</code> <code>float</code> <p>Prandtl number</p> required <p>Returns:</p> Name Type Description <code>k</code> <code>float</code> <p>Wave number</p> <code>Z</code> <code>float</code> <p>Surface impedance</p> <code>T</code> <code>float</code> <p>Transfer Matrix of the absorber</p> Source code in <code>src/models.py</code> <pre><code>class Porous_Absorber_JAC(AbsorberModelInterface):\n\"\"\"Johnson-Champoux-Allard Model for a porous absorber material.\n\n    Args:\n        f (float): Frequency\n        air_density (float): Density of air\n        air speed (float): Speed of air\n        sigma (float): Flow resistivity of material\n        L (float): Thickness of the layer\n        viscosity (float): Viscosity of air\n\n        air_pressure (float): Air pressure\n        phi (float): Porosity\n        alpha_inf (float): Tortuosity\n        kx (float): Wave number in x direction\n\n        gamma (float): Specific heat ratio\n        kappa (float): Thermal conductivity\n        cp (float): Specific heat capacity\n        K0 (float): Bulk modulus\n        delta_v (float): Viscous boundary layer thickness\n        delta_h (float): Thermal boundary layer thickness\n        Pr (float): Prandtl number\n\n\n    Returns:\n        k (float): Wave number\n        Z (float): Surface impedance\n        T (float): Transfer Matrix of the absorber\n    \"\"\"\n\n    def __init__(self, f, air_density, air_speed, L1, viscosity, sigma, air_pressure, phi, alpha_inf, kx):\n        super().__init__(f, air_density, air_speed, L1, viscosity)\n\n        self.sigma = sigma\n        self.air_pressure = air_pressure\n        self.phi = phi\n        self.alpha_inf = alpha_inf\n        self.kx = kx\n        self.gamma = 1.4\n        self.K0 = self.gamma * self.air_pressure\n        self.kappa = 0.0241\n        self.cp = 1.01\n        self.delta_v = np.sqrt(2 * self.viscosity / (self.air_density * self.omega))\n        self.delta_h = np.sqrt(2 * self.kappa / (self.air_density * self.omega * self.cp))\n        self.Pr = (self.delta_v / self.delta_h) ** 2\n        self.viscosity_L = 1 / 1 * np.sqrt(8 * self.viscosity * self.alpha_inf / (self.phi * self.sigma))\n        self.thermal_L = 2 * self.viscosity_L  # simpler formulations\n\n        self.G1 = self.sigma * self.phi / (self.alpha_inf * self.air_density * self.omega)\n        self.G2 = 4 * ((self.alpha_inf) ** 2) * self.air_density * self.viscosity * self.omega / ((self.sigma * self.phi * self.viscosity_L) ** 2)\n\n        self.G1_dot = 8 * self.viscosity / (self.air_density * self.Pr * ((self.thermal_L) ** 2) * self.omega)\n        self.G2_dot = self.air_density * self.Pr * ((self.thermal_L) ** 2) * self.omega / (16 * self.viscosity)\n        self.density_p = self.air_density * self.alpha_inf * (1 - 1j * self.G1 * np.sqrt(1 + 1j * self.G2)) / self.phi\n        self.Kp = self.K0 * self.phi ** (-1) / (self.gamma - (self.gamma - 1) * ((1 - 1j * self.G1_dot * np.sqrt(1 + 1j * self.G2_dot)) ** -1))\n\n    def get_k(self):\n        k = self.omega * np.sqrt(self.density_p / self.Kp)\n        return k\n\n    def get_Z(self):\n        Z = np.sqrt(self.density_p * self.Kp)\n        return Z\n\n    def get_T(self):\n        k = self.get_k()\n        Z = self.get_Z()\n        k_z = np.sqrt(k ** 2 - self.kx ** 2)\n\n        T = np.array([[np.cos(k_z * self.L1), 1j * Z * (k / k_z) * np.sin(k_z * self.L1)],\n                      [(1j / Z) * (k_z / k) * np.sin(k_z * self.L1), np.cos(k_z * self.L1)]])\n        return T\n</code></pre>"},{"location":"utils/","title":"Utility functions","text":""},{"location":"utils/#about","title":"About","text":"<p>Here are some useful functions that are used throughout the code.  They are mostly used inside the streamlit 'Home.py' file.</p>"},{"location":"utils/#src.utils.create_df_export_button","title":"<code>create_df_export_button(df, title, ts)</code>","text":"<p>Creates a Streamlit button to export a dataframe to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Dataframe to export</p> required <code>title</code> <code>str</code> <p>Title of the file being exported</p> required <code>ts</code> <code>pendulum.DateTime</code> <p>Optional datetime that will be used for file name</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Streamlit button functioning a boolean type</p> Source code in <code>src/utils.py</code> <pre><code>def create_df_export_button(\n        df: pd.DataFrame,\n        title: str,\n        ts: pendulum.DateTime | None,\n) -&gt; bool:\n\"\"\"Creates a Streamlit button to export a dataframe to a CSV file.\n\n    Args:\n        df (pd.DataFrame): Dataframe to export\n        title (str): Title of the file being exported\n        ts (pendulum.DateTime): Optional datetime that will be used for file name\n\n    Returns:\n        bool: Streamlit button functioning a boolean type\n    \"\"\"\n\n    if ts is None:\n        ts = pendulum.now()\n\n    ts_formatted = ts.to_datetime_string().translate(\n        str.maketrans(\n            {\n                \"/\": \"-\",\n                \":\": \"-\",\n            }\n        )\n    )\n\n    file_name = f\"{title}_{ts_formatted}.csv\".replace(\" \", \"_\").lower()\n\n    return st.download_button(\n        label=\"Export\",\n        data=_convert_df(df=df),\n        file_name=file_name,\n        mime=\"text/csv\",\n    )\n</code></pre>"},{"location":"utils/#src.utils.plotly_freq_bands","title":"<code>plotly_freq_bands(x, y, x_label, y_label, title, plot_type='oct')</code>","text":"<p>Creates a plotly-go bar plot for octave bands.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>List of x values</p> required <code>y</code> <code>list</code> <p>List of y values</p> required <code>x_label</code> <code>str</code> <p>Label for x axis</p> required <code>y_label</code> <code>str</code> <p>Label for y axis</p> required <code>title</code> <code>str</code> <p>Title of the plot</p> required <code>plot_type</code> <code>str</code> <p>Type of plot to create. Options are 'oct' and 'third'.</p> <code>'oct'</code> <p>Returns:</p> Type Description <p>plotly.graph_objects.Figure: Plotly bar plot.</p> Source code in <code>src/utils.py</code> <pre><code>def plotly_freq_bands(x, y, x_label, y_label, title, plot_type='oct'):\n\"\"\"Creates a plotly-go bar plot for octave bands.\n\n    Args:\n        x (list): List of x values\n        y (list): List of y values\n        x_label (str): Label for x axis\n        y_label (str): Label for y axis\n        title (str): Title of the plot\n        plot_type (str, optional): Type of plot to create. Options are 'oct' and 'third'.\n\n    Returns:\n        plotly.graph_objects.Figure: Plotly bar plot.\n    \"\"\"\n\n    if plot_type == 'oct':\n        center_freqs = [31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000]\n        bw_factor = 2\n    elif plot_type == 'third':\n        center_freqs = [25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200,\n                        250, 315, 400, 500, 630, 800, 1000, 1250, 1600, 2000,\n                        2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000]\n        bw_factor = 3\n    else:\n        raise ValueError(\"Invalid Plot Type\")\n\n    freq_bands = []\n\n    for center_freq in center_freqs:\n        lower_cutoff = center_freq / bw_factor\n        upper_cutoff = center_freq * bw_factor\n\n        freq_band = {\n            \"center_frequency\": center_freq,\n            \"lower_cutoff_frequency\": lower_cutoff,\n            \"upper_cutoff_frequency\": upper_cutoff\n        }\n\n        freq_bands.append(freq_band)\n\n    alphas_mean = []  # will hold the mean value for all alphas in each freq band\n\n    for band in freq_bands:\n        band_y_values = y[(x &gt;= band['lower_cutoff_frequency']) &amp; (x &lt;= band['upper_cutoff_frequency'])]\n        mean_y_value = np.mean(band_y_values) if len(band_y_values) &gt; 0 else 0\n        alphas_mean.append(mean_y_value)\n\n    # Create evenly spaced x-axis values for plotting\n    x_ticks = np.arange(len(center_freqs))\n\n    # Create bar plot\n    fig = go.Figure(data=go.Bar(x=x_ticks, y=alphas_mean))\n\n    # Set the x-axis tick positions and labels\n    fig.update_layout(\n        xaxis=dict(\n            tickvals=x_ticks,\n            ticktext=center_freqs,\n            title=x_label\n        ),\n        yaxis=dict(\n            range=[0, 1],\n            title=y_label\n        ),\n        title=title,\n        width=1000,\n        height=500\n    )\n\n    return fig\n</code></pre>"},{"location":"utils/#src.utils.plotly_go_line","title":"<code>plotly_go_line(x, y, x_label, y_label, title)</code>","text":"<p>Creates a plotly-go line plot.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list</code> <p>List of x values</p> required <code>y</code> <code>list</code> <p>List of y values</p> required <code>x_label</code> <code>str</code> <p>Label for x axis</p> required <code>y_label</code> <code>str</code> <p>Label for y axis</p> required <code>title</code> <code>str</code> <p>Title of the plot</p> required <p>Returns:</p> Type Description <p>plotly.graph_objects.Figure: Plotly line plot</p> Source code in <code>src/utils.py</code> <pre><code>def plotly_go_line(x, y, x_label, y_label, title):\n\"\"\"Creates a plotly-go line plot.\n\n    Args:\n        x (list): List of x values\n        y (list): List of y values\n        x_label (str): Label for x axis\n        y_label (str): Label for y axis\n        title (str): Title of the plot\n\n    Returns:\n        plotly.graph_objects.Figure: Plotly line plot\n    \"\"\"\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(x=x, y=y, mode='lines'))\n    fig.update_xaxes(showgrid=True, type='log')\n    fig.update_layout(title=title,\n                      xaxis_title=x_label,\n                      yaxis_title=y_label,\n                      yaxis_range=[0, 1],\n                      width=1000,\n                      height=500)\n    return fig\n</code></pre>"}]}